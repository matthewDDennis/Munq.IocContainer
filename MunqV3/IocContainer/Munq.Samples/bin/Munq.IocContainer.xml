<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Munq.IocContainer</name>
    </assembly>
    <members>
        <member name="T:Munq.LifetimeManagers.RequestLifetime">
            <summary>
            A lifetime manager that scopes the lifetime of created instances to the duration of the
            current HttpRequest.
            </summary>
            <example>
            In Web applications, it is sometime desirable to ensure that all classes use the same instance
            of a dependency, but only for the duration of the request.  One example might be a Repository
            that implements the Unit of Work pattern, such as an Entity Framework base repository.
            <code>
            public class ArticleRepository : IArticleRepository
            {
               ...
            }
            
            public class SpanishTranslator : IArticleTranslator
            {
                public SpanishTranslator(IArticleRepository repository)
                {
                    ...
                }
                ...
            }
             
            public class ArticleController : IController 
            {
                IArticleRepository _repository;
                IArticleTranslator _translator;
                public ArticleController(IArticleRepository repository, IArticleTranslator translator)
                {
                    _repository = repository;
                    _translator = translator;
                }
                
                public ActionResult Save(ArticleModel article)
                {
                    _repository.Save(article);
                    _translator.Save(article); // uses the same IArticleRepository instance
                    _repository.AcceptChanges();
                }
                ...
            }
            
                // initialization code, probably in global.ascx
            protected void Application_Start()
            {
            	DependencyResolver.SetResolver(new MunqDependencyResolver());
            	var ioc = MunqDependencyResolver.Container;
            	var requestLifetime = new RequestLifetime();
            	ioc.Register&lt;IArticleRepository, ArticleRepository&gt;()
            	   .WithLifetimeManager(requestLifetime);
            	ioc.Register&lt;IArticleTranslator, ArticleTranslator&gt;()
            	   .WithLifetimeManager(requestLifetime);
                ...
            </code>
            </example>
        </member>
        <member name="T:Munq.ILifetimeManager">
            <summary>
            Defines the functionality for Lifetime Managers.  Implementation should instantiate an 
            instance store and use the Registration's Key property to index the data in the store.
            This allows one lifetime manager to service multiple Registrations.
            </summary>
        </member>
        <member name="M:Munq.ILifetimeManager.GetInstance(Munq.IRegistration)">
            <summary>
            Get an instance for the registration, using the lifetime manager to cache instance
            as required by the scope of the lifetime manager.
            </summary>
            <param name="registration">
            The registration which is used to supply the storage key and create a new instance if
            required.
            </param>
            <returns>The cached or new instance.</returns>
        </member>
        <member name="M:Munq.ILifetimeManager.InvalidateInstanceCache(Munq.IRegistration)">
            <summary>
            Invalidate the instance in whatever storage is used by the lifetime manager.
            </summary>
            <param name="registration">
            The registration which is used to supply the storage key and create a new instance if
            required.
            </param>
        </member>
        <member name="M:Munq.LifetimeManagers.RequestLifetime.GetInstance(Munq.IRegistration)">
            <summary>
            Gets the instance from the Request Items, if available, otherwise creates a new
            instance and stores in the Request Items.
            </summary>
            <param name="registration">The creator (registration) to create a new instance.</param>
            <returns>The instance.</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.RequestLifetime.InvalidateInstanceCache(Munq.IRegistration)">
            <summary>
            Invalidates the cached value.
            </summary>
            <param name="registration">The Registration which is having its value invalidated</param>
        </member>
        <member name="M:Munq.LifetimeManagers.RequestLifetime.SetContext(System.Web.HttpContextBase)">
            <summary>
            Only used for testing.  Has no effect when in web application
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:Munq.LifetimeManagers.RequestLifetime.Context">
            <summary>
            Return the HttpContext if running in a web application, the test 
            context otherwise.
            </summary>
        </member>
        <member name="T:Munq.LifetimeManagers.ContainerLifetime">
            <summary>
            A lifetime manager that scopes the lifetime of created instances to the lifetime of the
            container.
            </summary>
        </member>
        <member name="M:Munq.LifetimeManagers.ContainerLifetime.GetInstance(Munq.IRegistration)">
            <summary>
            Gets the instance from the container instance cache, if available, otherwise creates a new
            instance and caches it. This effectively make the instance an application scoped Singleton.
            </summary>
            <param name="registration">The creator (registration) to create a new instance.</param>
            <returns>The instance.</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.ContainerLifetime.InvalidateInstanceCache(Munq.IRegistration)">
            <summary>
            Invalidates the cached value.
            </summary>
            <param name="registration">The Registration which is having its value invalidated</param>
        </member>
        <member name="T:Munq.IDependencyResolver">
            <summary>
			This interface defines the IOC container's functionality to resolve instances by type
			and distinguishing name.
		</summary>
        </member>
        <member name="M:Munq.IDependencyResolver.Resolve``1">
            <summary>Resolves the unnamed instance of the type TType.</summary><typeparam name="TType">The type that is to be resolved.</typeparam><returns>An instance of the class registered to resolve the type TType.</returns><example>
			This example gets an instance of the class registered , or result of the function registered 
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				ILogger logger = container.Resolve&lt;ILogger&lt;&gt;();
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.Resolve``1(System.String)">
            <summary>Resolves the named instance of the type TType.</summary><typeparam name="TType">The type that is to be resolved.</typeparam><param name="name">The name of the registration for type TType.</param><returns>An instance of the class registered to resolve the type TType.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				ILogger logger = container.Resolve&lt;ILogger&lt;&gt;("Database");
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.Resolve(System.Type)">
            <summary>Resolves the unnamed instance of the specified type.</summary><param name="type">The type that is to be resolved.</param><returns>An instance of the class registered to resolve the type.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				ILogger logger = container.Resolve(typeof(ILogger));
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.Resolve(System.String,System.Type)">
            <summary>Resolves the named instance of the specified type.</summary><param name="type">The type that is to be resolved.</param><param name="name">The name of the registration for type.</param><returns>An instance of the class registered to resolve the type TType.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				ILogger logger = container.Resolve("Database", typeof(ILogger));
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.ResolveAll``1">
            <summary>Gets of all possible named and unnamed resolutions for the type TType.</summary><typeparam name="TType">The type of which to get the instances.</typeparam><returns>A list of resolved instances.</returns><example>
			This example gets a list of plugins and initializes them.
			<code>
				...
				var plugins = container.ResolveAll&lt;IPlugin&gt;();
				foreach (var plugin in plugins)
					MyApp.Initialize(plugin);
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.ResolveAll(System.Type)">
            <summary>Gets of all possible named and unnamed resolutions for the specified type.</summary><param name="type">The type of which to get the instances.</param><returns>A list of resolved instances.</returns><example>
			This example gets a list of plugins and initializes them.
			<code>
				...
				var plugins = container.ResolveAll(typeof(IPlugin));
				foreach (var plugin in plugins)
				MyApp.Initialize(plugin);
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.LazyResolve``1">
            <summary>
			Gets a function that resolves the unnamed instance of the type TType.
			Used for delaying creating expensive resources until if and when required.	
		</summary><typeparam name="TType">The type that is to be resolved.</typeparam><returns>An instance of the class registered to resolve the type TType.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				Func&lt;ILogger&gt; loggerFunc = container.LazyResolve&lt;ILogger&lt;&gt;();
				...
				var logger = loggerFunc();
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.LazyResolve``1(System.String)">
            <summary>
			Gets a function that resolves the named instance of the type TType.
			Used for delaying creating expensive resources until if and when required.
		</summary><typeparam name="TType">The type that is to be resolved.</typeparam><param name="name">The name of the registration for type TType.</param><returns>An instance of the class registered to resolve the type TType.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				Func&lt;ILogger&gt; loggerFunc = container.LazyResolve&lt;ILogger&lt;&gt;("Database");
				...
				var logger = loggerFunc();
				logger.log(Log.Info, "Database Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.LazyResolve(System.Type)">
            <summary>
			Gets a function that resolves the unnamed instance of the specified type.
			Used for delaying creating expensive resources until if and when required.
		</summary><param name="type">The type that is to be resolved.</param><returns>An instance of the class registered to resolve the specified type.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				Func&lt;ILogger&gt; loggerFunc = container.LazyResolve&lt;ILogger&lt;&gt;();
				...
				var logger = loggerFunc();
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.LazyResolve(System.String,System.Type)">
            <summary>
			Gets a function that resolves the named instance of the specified type.
			Used for delaying creating expensive resources until if and when required.
		</summary><param name="name">The name of the registration for specified type.</param><param name="type">The type that is to be resolved.</param><returns>An instance of the class registered to resolve the specified type.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				Func&lt;ILogger&gt; loggerFunc = container.LazyResolve("Database", typeof(ILogger));
				... 
				var logger = loggerFunc();
				logger.log(Log.Info, "Database Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.CanResolve``1">
            <summary>Determines if the type TType can be resolved.</summary><typeparam name="TType">The type that is to be resolved.</typeparam><returns>True if there is an unnamed Registration for the type TType, false otherwise.</returns><remarks>If TType is a class, it may still be possible to resolve it.</remarks><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				if (!container.CanResolve&lt;ILogger&gt;())
					throw new Exception("Logging is not available");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.CanResolve``1(System.String)">
            <summary>Determines if the type TType can be resolved.</summary><typeparam name="TType">The type that is to be resolved.</typeparam><param name="name">The name of the Registration to check for.</param><returns>True if there is an named Registration for the type TType, false otherwise.</returns><remarks>If TType is a class, it may still be possible to resolve it.</remarks><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				if (!container.CanResolve&lt;ILogger&gt;("Database"))
					throw new Exception("Database Logging is not available");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.CanResolve(System.Type)">
            <summary>Determines if the specified type can be resolved.</summary><param name="type">The type that is to be resolved.</param><returns>True if there is an unnamed Registration for the specified type, false otherwise.</returns><remarks>If specified type is a class, it may still be possible to resolve it.</remarks><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				if (!container.CanResolve(typeof(ILogger))
					throw new Exception("Logging is not available");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependencyResolver.CanResolve(System.String,System.Type)">
            <summary>Determines if the specified type can be resolved.</summary><param name="name">The name of the Registration to check for.</param><param name="type">The type that is to be resolved.</param><returns>True if there is an named Registration for the specified type, false otherwise.</returns><remarks>If the specified type is a class, it may still be possible to resolve it.</remarks><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				if (!container.CanResolve&lt;ILogger&gt;("Database"))
					throw new Exception("Database Logging is not available");
			</code>
		</example>
        </member>
        <member name="T:Munq.Configuration.IMunqConfig">
            <summary>
            This interface is defined on classes that are used to dynamically register dependencies 
            in the container.  Classes implementing this interface can be discovered and the RegisterIn
            method automatically called.
            </summary>
        </member>
        <member name="M:Munq.Configuration.IMunqConfig.RegisterIn(Munq.IDependecyRegistrar)">
            <summary>
            Classes that implement this interface are automatically called to
            register type factories in the Munq IOC container
            </summary>
            <param name="container">The Munq IOC Container.</param>
        </member>
        <member name="T:Munq.IRegistrationKey">
            <summary>
            This interface is used internally to identify registrations in the type registry.
            </summary>
        </member>
        <member name="M:Munq.IRegistrationKey.GetInstanceType">
            <summary>
            Gets the type that this key identifies.
            </summary>
            <returns>Returns the type of the registration.</returns>
        </member>
        <member name="T:Munq.IContainerFluent">
            <summary>
			The IContainerFluent interface defined the fluent interface that can be used to configure
			the IocContainer.
		</summary>
        </member>
        <member name="M:Munq.IContainerFluent.UsesDefaultLifetimeManagerOf(Munq.ILifetimeManager)">
            <summary>
			Sets the LifetimeManager that will be used on new Registrations by default.  This can
			be changed calling WithRegistration on the IRegistration returned from a call to Register.
		</summary><param name="lifetimeManager">The Lifetime manager to use.</param><returns>'this' so that the method calls can be chained.</returns><example>
			<para>
				This example shows how an application wide instance of the IOC Container could be created
				and configured to scope resolved instances to the HttpRequest lifetime as a default.
			</para>
			<para>
				The class MyDatabase implements the IDatabase interface, and requires an instance of
				a class implementing ILogger as a constructor parameter.  The same instance of MyDatabase
				will be used for all instances Resolved for the duration of the current Http Request.
				The ILogger can be a Singleton and so the LifetimeManager is explicitly set.
			</para>
			<code>
				public class MyIocContainer
				{
					private static Container _container;
					private static ILifetimeManager = new RequestLifetime();

					public Container Container { get { return _container; } }

					// Initializes the Container to use the HttpRequest Lifetime Manager to scope
					// the resolved object to the current HttpRequest by default.
					public static MyContainer()
					{
						 _container = new IocContainer();
						 Container.UsesDefaultLifetimeManagerOf(_defaultLifetimeManager);
					 
						 Container.Register&lt;IDatabase, MyDatabase&gt;(); // RequestLifetime
						 Container.Register&lt;ILogger, MyLogger&gt;().WithLifetimeManager(new ContainerLifetime());
					}
				}
			</code>
		</example>
        </member>
        <member name="T:Munq.IocContainer">
            <summary>
            The implementation of the IOC container.  Implements the IDependencyRegistrar and
            IDependencyResolver, along with the IContainerFluent and IDisposable interfaces.
            The container is thread safe.
            </summary>
        </member>
        <member name="T:Munq.IDependecyRegistrar">
            <summary>
			The IDependencyRegistrar defines the methods used to manage Registration of functions or 
			instances which will be used to resolve instances of specified types, either without or
			without a distinguishing name.
		</summary>
        </member>
        <member name="M:Munq.IDependecyRegistrar.Register``1(System.Func{Munq.IDependencyResolver,``0})">
            <summary>
			Adds the function to resolve the unnamed registration of the specified type to the container.
		</summary><typeparam name="TType">The type to be registered.</typeparam><param name="func">
			The delegate  which will be called to create an instance of the type TType.
		</param><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			The following code registers a method that creates and instance of MyDatabase to create
			the object for when resolving the IDatabase interface.
			<code>
				var container = new IocContainer();
				container.Register&lt;IDatabase&gt;( c =&gt; new MyDatabase(c.Resolve&lt;ILogger&gt;()));
				...
				// get an IDatabase instance
				var aDatabase = container.Resolve&lt;IDatabase&gt;();
		</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.Register``1(System.String,System.Func{Munq.IDependencyResolver,``0})">
            <summary>
			Adds the function to resolve the named registration of the specified type to the container.
		</summary><typeparam name="TType">The type to be registered.</typeparam><param name="name">
			The name of the Registration for this type.  Use to distinguish between different
			Registrations.
		</param><param name="func">
			The delegate  which will be called to create an instance of the type TType.
		</param><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			The following code registers a method that creates and instance of MyDatabase to create
			the object for when resolving the IDatabase interface using a named instance.
			<code>
				var container = new IocContainer();
				container.Register&lt;IDatabase&gt;("Article", c =&gt; new MyArticleDatabase(c.Resolve&lt;ILogger&gt;()));
				container.Register&lt;IDatabase&gt;("Blog", c =&gt; new MyBlogDatabase(c.Resolve&lt;ILogger&gt;()));
				...
				// get an instance of the Article database
				var articleDatabase = container.Resolve&lt;IDatabase&gt;("Article");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.Register(System.Type,System.Func{Munq.IDependencyResolver,System.Object})">
            <summary>
			Adds the function to resolve the unnamed registration of the specified type to the container.
		</summary><param name="type">The type to be registered.</param><param name="func">
			The delegate which will be called to create an instance of the type.
		</param><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			The following code registers a method that creates and instance of MyDatabase to create
			the object for when resolving the IDatabase interface.
			<code>
				var container = new IocContainer();
				container.Register( typeof(IDatabase), c =&gt; new MyDatabase(c.Resolve&lt;ILogger&gt;()));
				...
				// get an IDatabase instance
				var aDatabase = container.Resolve&lt;IDatabase&gt;();
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.Register(System.String,System.Type,System.Func{Munq.IDependencyResolver,System.Object})">
            <summary>
			Adds the function to resolve the named registration of the specified type to the container.
		</summary><param name="name">
			The name of the Registration for this type.  Use to distinguish between different
			Registrations.
		</param><param name="type">The type to be registered.</param><param name="func">
			The delegate which will be called to create an instance of the type.
		</param><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			The following code registers a method that creates and instance of MyDatabase to create
			the object for when resolving the IDatabase interface using a named instance.
			<code>
				var container = new IocContainer();
				container.Register("Article", typeof(IDatabase), c =&gt; new MyArticleDatabase(c.Resolve&lt;ILogger&gt;()));
				container.Register("Blog", typeof(IDatabase), c =&gt; new MyBlogDatabase(c.Resolve&lt;ILogger&gt;()));
				...
				// get an instance of the Article database
				var articleDatabase = container.Resolve&lt;IDatabase&gt;("Article");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.RegisterInstance``1(``0)">
            <summary>
			Registers an instance that will be returned whenever the IocContainer resolves the specified
			type.
		</summary><typeparam name="TType">The type that is being registered for resolution.</typeparam><param name="instance">
			The instance that will alway be returned when TType is resolved.  The instance must be
			assignable to a variable of type TType.
		</param><remarks>
			Setting the LifetimeManager will have no affect.  The same instance will always be
			returned.  The lifetime is effectively ContainerLifetime The instance is a Singleton.
		</remarks><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			This example shows how to register a instance to be returned whenever a type is resolved.
			<code>
				var container = new.IocContainer();
				var logger = new ErrorLogger();
				container.Register&lt;ILogger&gt;(logger);
				...
				var logger1 = container.Resolve&lt;ILogger&gt;();
				var logger2 = container.Resolve&lt;ILogger&gt;();
				
				// logger1 and logger2 both reference the same object.
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.RegisterInstance``1(System.String,``0)">
            <summary>
			Registers an instance that will be returned whenever the IocContainer resolves the specified
			type and name.
		</summary><typeparam name="TType">The type that is being registered for resolution.</typeparam><param name="name">
			The name this registration will be registered under.
		</param><param name="instance">
			The instance that will alway be returned when TType is resolved.  The instance must be
			assignable to a variable of type TType.
		</param><remarks>
			Setting the LifetimeManager will have no affect.  The same instance will always be
			returned.  The lifetime is effectively ContainerLifetime The instance is a Singleton.
		</remarks><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			This example shows how to register a instance to be returned whenever a type is resolved.
			<code>
				var container = new.IocContainer();
				var articleRepository = new ArticleRepository();
				var blogRepository = new BlogRepository();
				container.Register&lt;IRepository&gt;("Article", articleRepository);
				container.Register&lt;IRepository&gt;("Blog", blogRepository);
				...
				var repository1 = container.Resolve&lt;IRepository&gt;("Article");
				var repository2 = container.Resolve&lt;IRepository&gt;("Article");
				var repository3 = container.Resolve&lt;IRepository&gt;("Blog");

				// repository1 and repository2 both reference the same object, while repository3
				// references a different object.
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.RegisterInstance(System.Type,System.Object)">
            <summary>
			Registers an instance that will be returned whenever the IocContainer resolves the specified
			type.
		</summary><param name="type">The type that is being registered for resolution.</param><param name="instance">
			The instance that will alway be returned when type is resolved.
		</param><remarks>
			Setting the LifetimeManager will have no affect.  The same instance will always be
			returned.  The lifetime is effectively ContainerLifetime The instance is a Singleton.
		</remarks><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			This example shows how to register a instance to be returned whenever a type is resolved.
			<code>
				var container = new.IocContainer();
				var logger = new ErrorLogger();
				container.Register(typeof(ILogger), logger);
				...
				var logger1 = container.Resolve&lt;ILogger&gt;();
				var logger2 = container.Resolve&lt;ILogger&gt;();

				// logger1 and logger2 both reference the same object.
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.RegisterInstance(System.String,System.Type,System.Object)">
            <summary>
			Registers an instance that will be returned whenever the IocContainer resolves the specified
			type and name.
		</summary><param name="type">The type that is being registered for resolution.</param><param name="name">The name this registration will be registered under.</param><param name="instance">
			The instance that will alway be returned when TType is resolved.  The instance must be
			assignable to a variable of type TType.
		</param><remarks>
			Setting the LifetimeManager will have no affect.  The same instance will always be
			returned.  The lifetime is effectively ContainerLifetime The instance is a Singleton.
		</remarks><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			This example shows how to register a instance to be returned whenever a type is resolved.
			<code>
				var container = new.IocContainer();
				var articleRepository = new ArticleRepository();
				var blogRepository = new BlogRepository();
				container.Register("Article", typeof(IRepository), articleRepository);
				container.Register("Blog", typeof(IRepository), blogRepository);
				...
				var repository1 = container.Resolve&lt;IRepository&gt;("Article");
				var repository2 = container.Resolve&lt;IRepository&gt;("Article");
				var repository3 = container.Resolve&lt;IRepository&gt;("Blog");

				// repository1 and repository2 both reference the same object while repository3
				// references a different object.
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.Register``2">
            <summary>
			Registers a implementation type to be instantiated when the the specified type is resolved.
		</summary><typeparam name="TType">The type to be registered.</typeparam><typeparam name="TImpl">
			The type that will be instantiated when TType is resolved.  The instance is created using
			the constructor with the most parameters, each parameter is resolved by the IOC Container.
		</typeparam><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			The following code registers a method that creates and instance of MyDatabase to create
			the object for when resolving the IDatabase interface.
			<code>
				var container = new IocContainer();
				container.Register&lt;IDatabase, MyDatabase&gt;( );
				...
				// get an IDatabase instance
				var aDatabase = container.Resolve&lt;IDatabase&gt;();
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.Register``2(System.String)">
            <summary>
			Registers a implementation type to be instantiated when the the specified type is resolved.
		</summary><typeparam name="TType">The type to be registered.</typeparam><param name="name">
			The name of the Registration for this type.  Use to distinguish between different
			Registrations.
		</param><typeparam name="TImpl">
			The type that will be instantiated when TType is resolved.  The instance is created using
			the constructor with the most parameters, each parameter is resolved by the IOC Container.
		</typeparam><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			The following code registers a method that creates and instance of MyDatabase to create
			the object for when resolving the IDatabase interface using a named instance.
			<code>
				var container = new IocContainer();
				container.Register&lt;IDatabase, MyArticleDatabase&gt;("Article");
				container.Register&lt;IDatabase, MyBlogDatabase&gt;("Blog");
				...
				// get an instance of the Article database
				var articleDatabase = container.Resolve&lt;IDatabase&gt;("Article");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.Register(System.Type,System.Type)">
            <summary>
			Registers a implementation type to be instantiated when the the specified type is resolved.
		</summary><param name="tType">The type to be registered.</param><param name="tImpl">
			The type that will be instantiated when tType is resolved.  The instance is created using
			the constructor with the most parameters, each parameter is resolved by the IOC Container.
		</param><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			The following code registers a method that creates and instance of MyDatabase to create
			the object for when resolving the IDatabase interface.
			<code>
				var container = new IocContainer();
				container.Register( typeof(IDatabase), typeof(MyDatabase));
				...
				// get an IDatabase instance
				var aDatabase = container.Resolve&lt;IDatabase&gt;();
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.Register(System.String,System.Type,System.Type)">
            <summary>
			Registers a implementation type to be instantiated when the the specified type is resolved.
		</summary><param name="name">
			The name of the Registration for this type.  Use to distinguish between different
			Registrations.
		</param><param name="tType">The type to be registered.</param><param name="tImpl">
			The type that will be instantiated when tType is resolved.  The instance is created using
			the constructor with the most parameters, each parameter is resolved by the IOC Container.
		</param><returns>
			An instance of IRegistration that can be used to configure how the get information about
			the registration, or change the lifetime manager.
		</returns><example>
			The following code registers a method that creates and instance of MyDatabase to create
			the object for when resolving the IDatabase interface using a named instance.
			<code>
				var container = new IocContainer();
				container.Register("Article", typeof(IDatabase), typeof(MyArticleDatabase));
				container.Register("Blog", typeof(IDatabase), typeof(MyBlogDatabase));
				...
				// get an instance of the Article database
				var articleDatabase = container.Resolve&lt;IDatabase&gt;("Article");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.Remove(Munq.IRegistration)">
            <summary>
			Removes the Registration from the IOC Container.
		</summary><param name="ireg">
			The Registration to be removed from the container.
		</param><example>
			The following gets a Registration and removes it from the container.
			<code>
				var container = new IocContainer();
				container.Register&lt;IMagicUser, Elf&gt;("Elf");
				...
				// this works
				var newPlayer = container.Resolve&lt;IMagicUser&gt;("Elf");
				...
				// Remove Elf from the possible magic users
				var registration = container.GetRegistration&lt;IMagicUser&gt;("Elf");
				container.Remove(registration);
				...
				// this throws a KeyNotFoundException
				var newPlayer = container.Resolve&lt;IMagicUser&gt;("Elf");
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.GetRegistration``1">
            <summary>
			Returns an Registration of a registered type
		</summary><typeparam name="TType">The type to get the Registration for.</typeparam><returns>An Registration for the type.  Throws a KeyNoFoundException if not registered.</returns><example>
			This example gets a Registration and invalidates the cached value.
			<code>
				var container = new IocContainer();
				container.Register&lt;IGameBoard, 3DGameBoard&gt;()
						 .WithLifetimeManager(new ContainerLifeTime());
				...
				// this create the instance, and caches it in the container
				var gameBoard = container.Resolve&lt;IGameBoard&gt;();
				...
				// force a new gameboard
				var registration = container.GetRegistration&lt;IGameBoard&gt;();
				registration.InvalidateInstanceCache();
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.GetRegistration``1(System.String)">
            <summary>
			Returns an Registration of a registered type
		</summary><typeparam name="TType">The type to get the Registration for.</typeparam><param name="name">The name associated with the named registration to get.</param><returns>An Registration for the type.  Throws a KeyNoFoundException if not registered.</returns><example>
			This example uses GetRegistration to ensure that the interface is Registered.
			<code>
				var container = new IocContainer();
				...
				IRegistration reg;
				try
				{
					reg = container.GetRegistration&lt;IArmory&gt;();
				}
				catch(KeyNotFoundException)
				{
					reg = container.Register&lt;IArmor, ElvenFortArmory&gt;();
				}
				// make sure it is a new instance.
				reg.InvalidateInstanceCache();
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.GetRegistration(System.Type)">
            <summary>
			Returns an Registration of a registered type
		</summary><param name="type">The type to get the Registration for.</param><returns>An Registration for the type.  Throws a KeyNoFoundException if not registered.</returns><example>
			This example gets a Registration and invalidates the cached value.
			<code>
				var container = new IocContainer();
				container.Register&lt;IGameBoard, 3DGameBoard&gt;()
				.WithLifetimeManager(new ContainerLifeTime());
				...
				// this create the instance, and caches it in the container
				var gameBoard = container.Resolve&lt;IGameBoard&gt;();
				...
				// force a new gameboard
				var registration = container.GetRegistration(typeof(IGameBoard));
				registration.InvalidateInstanceCache();
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.GetRegistration(System.String,System.Type)">
            <summary>
			Returns an Registration of a registered type
		</summary><param name="name">The name associated with the named registration to get.</param><param name="type">The type to get the Registration for.</param><returns>An Registration for the type.  Throws a KeyNoFoundException if not registered.</returns><example>
			This example uses GetRegistration to ensure that the interface is Registered.
			<code>
				var container = new IocContainer();
				...
				IRegistration reg;
				try
				{
					reg = container.GetRegistration("Elf",typeof(IArmory));
				}
				catch(KeyNotFoundException)
				{
					reg = container.Register&lt;IArmor, ElvenFortArmory&gt;("Elf");
				}
				// make sure it is a new instance.
				reg.InvalidateInstanceCache();
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.GetRegistrations``1">
            <summary>
			Gets all Registrations for the specified type.
		</summary><typeparam name="TType">The type for which the Registrations are required.</typeparam><returns>An list of the registration of the specified type.</returns><example>
			This example gets a list of the names of plugins registered.
			<code>
				...
				public IList&lt;string&gt; GetPluginNames(IocContainer container)
				{
					var registrations = container.GetRegistrations&lt;IPlugin&gt;();
					return registrations.Select(reg =&gt; reg.Name).ToList();
				}
			</code>
		</example>
        </member>
        <member name="M:Munq.IDependecyRegistrar.GetRegistrations(System.Type)">
            <summary>
			Gets all Registrations for the specified type.
		</summary><param name="type">The type for which the Registrations are required.</param><returns>An list of the registration of the specified type.</returns><example>
			This example gets a list of the names of plugins registered.
			<code>
				...
				public IList&lt;string&gt; GetPluginNames(IocContainer container)
				{
					var registrations = container.GetRegistrations(typeof(IPlugin));
					return registrations.Select(reg =&gt; reg.Name).ToList();
				}
			</code>
		</example>
        </member>
        <member name="P:Munq.IDependecyRegistrar.DefaultLifetimeManager">
            <summary>
			Gets or sets the LifetimeManger that is used by the IocContainer for new Registrations by
			default.
		</summary><remarks>
			A value of null is the same as ContainerLifetime, but slightly more efficient.
		</remarks><example>
			The following examples sets the default lifetime for resolved object to the life of the
			container.  In other words, the same instance will always be returned, effectively making
			all resolved objects Singletons.
			<code>
				var container = new IocContainer();
				container.DefaultLifetimeManager(new ContainerLifetime());
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.Resolve``1">
            <summary>Resolves the unnamed instance of the type TType.</summary><typeparam name="TType">The type that is to be resolved.</typeparam><returns>An instance of the class registered to resolve the type TType.</returns><example>
			This example gets an instance of the class registered , or result of the function registered 
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				ILogger logger = container.Resolve&lt;ILogger&lt;&gt;();
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.Resolve``1(System.String)">
            <summary>Resolves the named instance of the type TType.</summary><typeparam name="TType">The type that is to be resolved.</typeparam><param name="name">The name of the registration for type TType.</param><returns>An instance of the class registered to resolve the type TType.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				ILogger logger = container.Resolve&lt;ILogger&lt;&gt;("Database");
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.Resolve(System.Type)">
            <summary>Resolves the unnamed instance of the specified type.</summary><param name="type">The type that is to be resolved.</param><returns>An instance of the class registered to resolve the type.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				ILogger logger = container.Resolve(typeof(ILogger));
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.Resolve(System.String,System.Type)">
            <summary>Resolves the named instance of the specified type.</summary><param name="type">The type that is to be resolved.</param><param name="name">The name of the registration for type.</param><returns>An instance of the class registered to resolve the type TType.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				ILogger logger = container.Resolve("Database", typeof(ILogger));
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.CanResolve``1">
            <summary>Determines if the type TType can be resolved.</summary><typeparam name="TType">The type that is to be resolved.</typeparam><returns>True if there is an unnamed Registration for the type TType, false otherwise.</returns><remarks>If TType is a class, it may still be possible to resolve it.</remarks><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				if (!container.CanResolve&lt;ILogger&gt;())
					throw new Exception("Logging is not available");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.CanResolve``1(System.String)">
            <summary>Determines if the type TType can be resolved.</summary><typeparam name="TType">The type that is to be resolved.</typeparam><param name="name">The name of the Registration to check for.</param><returns>True if there is an named Registration for the type TType, false otherwise.</returns><remarks>If TType is a class, it may still be possible to resolve it.</remarks><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				if (!container.CanResolve&lt;ILogger&gt;("Database"))
					throw new Exception("Database Logging is not available");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.CanResolve(System.Type)">
            <summary>Determines if the specified type can be resolved.</summary><param name="type">The type that is to be resolved.</param><returns>True if there is an unnamed Registration for the specified type, false otherwise.</returns><remarks>If specified type is a class, it may still be possible to resolve it.</remarks><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				if (!container.CanResolve(typeof(ILogger))
					throw new Exception("Logging is not available");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.CanResolve(System.String,System.Type)">
            <summary>Determines if the specified type can be resolved.</summary><param name="name">The name of the Registration to check for.</param><param name="type">The type that is to be resolved.</param><returns>True if there is an named Registration for the specified type, false otherwise.</returns><remarks>If the specified type is a class, it may still be possible to resolve it.</remarks><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				if (!container.CanResolve&lt;ILogger&gt;("Database"))
					throw new Exception("Database Logging is not available");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.ResolveAll``1">
            <summary>Gets of all possible named and unnamed resolutions for the type TType.</summary><typeparam name="TType">The type of which to get the instances.</typeparam><returns>A list of resolved instances.</returns><example>
			This example gets a list of plugins and initializes them.
			<code>
				...
				var plugins = container.ResolveAll&lt;IPlugin&gt;();
				foreach (var plugin in plugins)
					MyApp.Initialize(plugin);
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.ResolveAll(System.Type)">
            <summary>Gets of all possible named and unnamed resolutions for the specified type.</summary><param name="type">The type of which to get the instances.</param><returns>A list of resolved instances.</returns><example>
			This example gets a list of plugins and initializes them.
			<code>
				...
				var plugins = container.ResolveAll(typeof(IPlugin));
				foreach (var plugin in plugins)
				MyApp.Initialize(plugin);
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.LazyResolve``1">
            <summary>
			Gets a function that resolves the unnamed instance of the type TType.
			Used for delaying creating expensive resources until if and when required.	
		</summary><typeparam name="TType">The type that is to be resolved.</typeparam><returns>An instance of the class registered to resolve the type TType.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				Func&lt;ILogger&gt; loggerFunc = container.LazyResolve&lt;ILogger&lt;&gt;();
				...
				var logger = loggerFunc();
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.LazyResolve``1(System.String)">
            <summary>
			Gets a function that resolves the named instance of the type TType.
			Used for delaying creating expensive resources until if and when required.
		</summary><typeparam name="TType">The type that is to be resolved.</typeparam><param name="name">The name of the registration for type TType.</param><returns>An instance of the class registered to resolve the type TType.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				Func&lt;ILogger&gt; loggerFunc = container.LazyResolve&lt;ILogger&lt;&gt;("Database");
				...
				var logger = loggerFunc();
				logger.log(Log.Info, "Database Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.LazyResolve(System.Type)">
            <summary>
			Gets a function that resolves the unnamed instance of the specified type.
			Used for delaying creating expensive resources until if and when required.
		</summary><param name="type">The type that is to be resolved.</param><returns>An instance of the class registered to resolve the specified type.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DefaultLogger&lt;&gt;();
				...
				Func&lt;ILogger&gt; loggerFunc = container.LazyResolve&lt;ILogger&lt;&gt;();
				...
				var logger = loggerFunc();
				logger.log(Log.Info, "Logging is active.");
			</code>
		</example>
        </member>
        <member name="M:Munq.IocContainer.LazyResolve(System.String,System.Type)">
            <summary>
			Gets a function that resolves the named instance of the specified type.
			Used for delaying creating expensive resources until if and when required.
		</summary><param name="name">The name of the registration for specified type.</param><param name="type">The type that is to be resolved.</param><returns>An instance of the class registered to resolve the specified type.</returns><example>
			This example gets an instance of the class registered , or result of the function registered
			for the type.
			<code>
				...
				container.Register&lt;ILogger, DatabaseLogger&lt;&gt;("Database");
				...
				Func&lt;ILogger&gt; loggerFunc = container.LazyResolve("Database", typeof(ILogger));
				... 
				var logger = loggerFunc();
				logger.log(Log.Info, "Database Logging is active.");
			</code>
		</example>
            <inheritdoc/>
        </member>
        <member name="M:Munq.IocContainer.UsesDefaultLifetimeManagerOf(Munq.ILifetimeManager)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.#ctor">
            <summary>
            Initializes a new instance of the IocContainer class;
            The types IocContainer, IDependencyRegistrar, and IDependencyResolver are all registered
            to resolve to this instance of the class.
            </summary>
        </member>
        <member name="M:Munq.IocContainer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <remarks>
            Disposes of all Container scoped (ContainerLifetime) instances cached in the type registry, and
            disposes of the type registry itself.
            </remarks>
        </member>
        <member name="M:Munq.IocContainer.Dispose(System.Boolean)">
            <summary>
            Implements the Disposed(boolean disposing) method of Disposable pattern.
            </summary>
            <param name="disposing">True if disposing.</param>
        </member>
        <member name="M:Munq.IocContainer.Finalize">
            <summary>
            The finalizer just ensures the container is disposed.
            </summary>
        </member>
        <member name="M:Munq.IocContainer.Register``1(System.Func{Munq.IDependencyResolver,``0})">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.Register``1(System.String,System.Func{Munq.IDependencyResolver,``0})">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.Register(System.Type,System.Func{Munq.IDependencyResolver,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.Register(System.String,System.Type,System.Func{Munq.IDependencyResolver,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.Register``2">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.Register``2(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.Register(System.Type,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.Register(System.String,System.Type,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.RegisterInstance``1(``0)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.RegisterInstance``1(System.String,``0)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.RegisterInstance(System.Type,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.RegisterInstance(System.String,System.Type,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.Remove(Munq.IRegistration)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.GetRegistration``1">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.GetRegistration``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.GetRegistration(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.GetRegistration(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.GetRegistrations``1">
            <inheritdoc />
        </member>
        <member name="M:Munq.IocContainer.GetRegistrations(System.Type)">
            <inheritdoc />
        </member>
        <member name="P:Munq.IocContainer.DefaultLifetimeManager">
            <inheritdoc />
        </member>
        <member name="T:Munq.CreateInstanceDelegateFactory">
            <summary>
            This class provides a method to build a delegate to create a specified type.  It is used
            by Register&lt;TType, TImp&gt;() to build the Func&lt;IDependencyResolver, TImp&gt; need
            to create the instance to be returned.  Also used by the Resolve methods if the type requested
            is a class, not an interface, and is not currently Registered in the container.
            </summary>
        </member>
        <member name="M:Munq.CreateInstanceDelegateFactory.Create(System.Type)">
            <summary>
            Build a delegate to return an instance of the specified type given an instance of IocContainer.
            Finds the public constructor with the most parameters.  The resulting method calls the container
            to resolve each parameter in the constructor.
            </summary>
            <param name="tImpl">The class to be resolved.</param>
            <returns>The delegate to create an instance of the class.</returns>
        </member>
        <member name="T:Munq.LifetimeManagers.AlwaysNewLifetime">
            <summary>
            A Lifetime Manager that always returns a new instance.
            </summary>
            <remarks>
            <para>Setting the IocContainer's or Registration's lifetime manager to null is equivalent
            to setting it to an instance of AlwaysNewLifetime. This is the default lifetime manager
            for the IocContainer.</para>
            The one instance can be used for all registrations. 
            </remarks>
            <example>
            The IocContainer default lifetime manager is set to Request lifetime, but one interface
            needs to alway be a new instance.
            <code>
                var requestLifetime   = new RequestLifetime();
                var alwaysNewLifetime = new AlwaysNewLifetime();
                var container         = new IocContainer();
                
                container.UsesDefaultLifetimeManagerOf(requestLifetime);
                container.Register&lt;IMyInterface, MyImplementation&gt;()
            		     .WithLifetimeManager(alwaysNewLifetime);
                container.Register&lt;IMyInterface2, MyImplementation2&gt;()
            		     .WithLifetimeManager(alwaysNewLifetime);
                ...
            </code>
            </example>
        </member>
        <member name="M:Munq.LifetimeManagers.AlwaysNewLifetime.GetInstance(Munq.IRegistration)">
            <summary>
            Always creates a new instance.
            </summary>
            <param name="registration">The creator (registration) that can create an instance</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.AlwaysNewLifetime.InvalidateInstanceCache(Munq.IRegistration)">
            <summary>
            Does nothing as this lifetime manager does not cache.
            </summary>
            <param name="registration">The registration.</param>
        </member>
        <member name="T:Munq.IRegistration">
            <summary>
            This is the result of registering a type in the container.
            </summary>
        </member>
        <member name="M:Munq.IRegistration.WithLifetimeManager(Munq.ILifetimeManager)">
            <summary>
            Sets the lifetime manager to be used by this Registration.
            </summary>
            <param name="manager">The ILifetimeManager to use.</param>
            <returns>'this', or the Registration.</returns>
        </member>
        <member name="M:Munq.IRegistration.InvalidateInstanceCache">
            <summary>
            Invalidates any cached value so that a new instance will be created on
            the next Resolve call.
            </summary>
        </member>
        <member name="M:Munq.IRegistration.CreateInstance">
            <summary>
            Creates an instance of the type using the registered function.
            </summary>
            <returns>The new instance.</returns>
        </member>
        <member name="P:Munq.IRegistration.Name">
            <summary>
            Gets the name of the registration.
            </summary>
        </member>
        <member name="P:Munq.IRegistration.Key">
            <summary>
            Gets the key that is used to identify cached values.
            </summary>
        </member>
        <member name="P:Munq.IRegistration.ResolvesTo">
            <summary>
            Gets the type the contain will Resolve to when this Registration is used.
            </summary>
        </member>
        <member name="T:Munq.LifetimeManagers.CachedLifetime">
            <summary>
            A Lifetime Manager that uses the Cache to store the instance
            </summary>
            <remarks>
            The cache can be invalidated at any time.  After that, the next Resolve will create a new 
            instance will be created and cached.  Don't assume that instances are the same.
            </remarks>
            <example>
            This example uses the IocContainer to cache RSS feeds for 15 minutes, and reloads on the
            next request after that.
            <code>
                 var container = new IocContainer();
                 var cachedFor15Minutes = new CachedLifetime().ExpiresAfter(new TimeSpan(0, 15, 0));
                 
            	 container.Register&lt;IRssFeed&gt;("Munq",    c => new RssFeed("http://munq.codeplex.com/Project/ProjectRss.aspx"))
            	          .WithLifetimeManager(cachedFor15Minutes);
            	          
            	 container.Register&lt;IRssFeed&gt;("TheGu",   c => new RssFeed("http://weblogs.asp.net/scottgu/rss.aspx"))
            	          .WithLifetimeManager(cachedFor15Minutes);
            	          
            	 container.Register&lt;IRssFeed&gt;("Haacked", c => new RssFeed("http://feeds.haacked.com/haacked/"))
            	          .WithLifetimeManager(cachedFor15Minutes);
            	 ...         
                 var feed = container.Resolve&lt;IRssFeed&gt;("TheGu");
            </code>
            </example>
        </member>
        <member name="M:Munq.LifetimeManagers.CachedLifetime.GetInstance(Munq.IRegistration)">
            <summary>
            Gets the instance from cache, if available, otherwise creates a new
            instance and caches it.
            </summary>
            <param name="registration">The creator (registration) to create a new instance.</param>
            <returns>The instance.</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.CachedLifetime.InvalidateInstanceCache(Munq.IRegistration)">
            <summary>
            Invalidates the cached value.
            </summary>
            <param name="registration">The Registration which is having its value invalidated</param>
        </member>
        <member name="M:Munq.LifetimeManagers.CachedLifetime.IsDependentOn(System.Web.Caching.CacheDependency)">
            <summary>
            Sets the Cache Dependencies for this LifetimeManager.
            </summary>
            <param name="dependencies">The CacheDependencies.</param>
            <returns>The CachedLifetime instance (allows chaining).</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.CachedLifetime.ExpiresOn(System.DateTime)">
            <summary>
            Sets the absolute time when the cached value expires.
            </summary>
            <param name="absoluteExpiration">The date/time when the item expires.</param>
            <returns>The CachedLifetime instance (allows chaining).</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.CachedLifetime.ExpiresAfterNotAccessedFor(System.TimeSpan)">
            <summary>
            Sets the duration the cached item will remain valid.  This is a sliding duration.
            </summary>
            <param name="duration">The duration. Use Cache.NoSlidingExpiration to disable.</param>
            <returns>The CachedLifetime instance (allows chaining).</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.CachedLifetime.ExpiresAfter(System.TimeSpan)">
            <summary>
            Sets the duration the cached item will remain valid.  This is a fixed duration.
            </summary>
            <param name="duration">The duration. Use Cache.NoSlidingExpiration to disable.</param>
            <returns>The CachedLifetime instance (allows chaining).</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.CachedLifetime.WithPriority(System.Web.Caching.CacheItemPriority)">
            <summary>
            Sets the priority of the item in the cache.
            </summary>
            <param name="priority">The priority.</param>
            <returns>The CachedLifetime instance (allows chaining).</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.CachedLifetime.CallbackOnRemoval(System.Web.Caching.CacheItemRemovedCallback)">
            <summary>
            Sets a callback method for when an item is removed (expires).
            </summary>
            <param name="onRemoveCallback">The callback method.</param>
            <returns>The CachedLifetime instance (allows chaining).</returns>
        </member>
        <member name="T:Munq.Configuration.ConfigurationLoader">
            <summary>
            This static class contains methods to discover classes that implement the IMunqConfig interface
            and to call the RegisterIn method on them.
            </summary>
        </member>
        <member name="M:Munq.Configuration.ConfigurationLoader.FindAndRegisterDependencies(Munq.IocContainer)">
            <summary>
            Finds all the types that implement the IMunqConfig interface, create an instance and 
            then call the RegisterIn method on the type.  The bin directory is checked for web
            applications, the current directory for Windows applications.
            </summary>
            <param name="container">The Munq IOC container to register class factories in.</param>
        </member>
        <member name="M:Munq.Configuration.ConfigurationLoader.CallRegistrarsInDirectory(Munq.IocContainer,System.String,System.String)">
            <summary>
            Finds all the types that implement the IMunqConfig interface, create an instance and 
            then call the RegisterIn method on the type.
            </summary>
            <param name="container">The Munq IOC container to register the class factories in.</param>
            <param name="binPath">The path of the directory to search.</param>
            <param name="filePattern">The optional file pattern for files to check. The default is *.dll</param>
        </member>
        <member name="M:Munq.Configuration.ConfigurationLoader.CallRegistrarsInAssembly(Munq.IocContainer,System.String)">
            <summary>
            Finds all classes the IMunqConfig interface in an assembly and call the RegisterIn
            method on each.
            </summary>
            <param name="container">The Munq IOC Container.</param>
            <param name="filename">The full filename to be loaded and checked.</param>
        </member>
        <member name="T:Munq.LifetimeManagers.SessionLifetime">
            <summary>
            A lifetime manager that scopes the lifetime of created instances to the current browser
            session.  An example of a class that might have Session Lifetime would be a Shopping Cart,
            or a multi-page entry form.
            </summary>
        </member>
        <member name="M:Munq.LifetimeManagers.SessionLifetime.GetInstance(Munq.IRegistration)">
            <summary>
            Gets the instance from the Session, if available, otherwise creates a new
            instance and stores in the Session.
            </summary>
            <param name="registration">The creator (registration) to create a new instance.</param>
            <returns>The instance.</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.SessionLifetime.InvalidateInstanceCache(Munq.IRegistration)">
            <summary>
            Invalidates the cached value.
            </summary>
            <param name="registration">The Registration which is having its value invalidated</param>
        </member>
        <member name="M:Munq.LifetimeManagers.SessionLifetime.SetContext(System.Web.HttpContextBase)">
            <summary>
             Only used for testing.  Has no effect when in web application
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:Munq.LifetimeManagers.SessionLifetime.Session">
            <summary>
            Gets the Session.
            </summary>
        </member>
        <member name="T:Munq.LifetimeManagers.ThreadLocalStorageLifetime">
            <summary>
            A LifetimeManager that uses Thread Local Storage to cache instances.
            </summary>
        </member>
        <member name="M:Munq.LifetimeManagers.ThreadLocalStorageLifetime.GetInstance(Munq.IRegistration)">
            <summary>
            Gets an instance from the thread local storage, or creates a new instance if not found.
            </summary>
            <param name="creator">The IInstanceCreate to use to get the Key and create new if required.</param>
            <returns>The instance.</returns>
        </member>
        <member name="M:Munq.LifetimeManagers.ThreadLocalStorageLifetime.InvalidateInstanceCache(Munq.IRegistration)">
            <summary>
            Removes the instance for the registration from the local storage cache.
            </summary>
            <param name="registration">The IRegistration returned when the type was registered in the IOC container.</param>
        </member>
    </members>
</doc>
